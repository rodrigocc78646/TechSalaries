{"ast":null,"code":"/*\nstring.js - Copyright (C) 2012-2014, JP Richardson <jprichardson@gmail.com>\n*/\n!function () {\n  \"use strict\";\n\n  var VERSION = '3.3.3';\n  var ENTITIES = {}; // from http://semplicewebsites.com/removing-accents-javascript\n\n  var latin_map = {\n    \"Á\": \"A\",\n    \"Ă\": \"A\",\n    \"Ắ\": \"A\",\n    \"Ặ\": \"A\",\n    \"Ằ\": \"A\",\n    \"Ẳ\": \"A\",\n    \"Ẵ\": \"A\",\n    \"Ǎ\": \"A\",\n    \"Â\": \"A\",\n    \"Ấ\": \"A\",\n    \"Ậ\": \"A\",\n    \"Ầ\": \"A\",\n    \"Ẩ\": \"A\",\n    \"Ẫ\": \"A\",\n    \"Ä\": \"A\",\n    \"Ǟ\": \"A\",\n    \"Ȧ\": \"A\",\n    \"Ǡ\": \"A\",\n    \"Ạ\": \"A\",\n    \"Ȁ\": \"A\",\n    \"À\": \"A\",\n    \"Ả\": \"A\",\n    \"Ȃ\": \"A\",\n    \"Ā\": \"A\",\n    \"Ą\": \"A\",\n    \"Å\": \"A\",\n    \"Ǻ\": \"A\",\n    \"Ḁ\": \"A\",\n    \"Ⱥ\": \"A\",\n    \"Ã\": \"A\",\n    \"Ꜳ\": \"AA\",\n    \"Æ\": \"AE\",\n    \"Ǽ\": \"AE\",\n    \"Ǣ\": \"AE\",\n    \"Ꜵ\": \"AO\",\n    \"Ꜷ\": \"AU\",\n    \"Ꜹ\": \"AV\",\n    \"Ꜻ\": \"AV\",\n    \"Ꜽ\": \"AY\",\n    \"Ḃ\": \"B\",\n    \"Ḅ\": \"B\",\n    \"Ɓ\": \"B\",\n    \"Ḇ\": \"B\",\n    \"Ƀ\": \"B\",\n    \"Ƃ\": \"B\",\n    \"Ć\": \"C\",\n    \"Č\": \"C\",\n    \"Ç\": \"C\",\n    \"Ḉ\": \"C\",\n    \"Ĉ\": \"C\",\n    \"Ċ\": \"C\",\n    \"Ƈ\": \"C\",\n    \"Ȼ\": \"C\",\n    \"Ď\": \"D\",\n    \"Ḑ\": \"D\",\n    \"Ḓ\": \"D\",\n    \"Ḋ\": \"D\",\n    \"Ḍ\": \"D\",\n    \"Ɗ\": \"D\",\n    \"Ḏ\": \"D\",\n    \"ǲ\": \"D\",\n    \"ǅ\": \"D\",\n    \"Đ\": \"D\",\n    \"Ƌ\": \"D\",\n    \"Ǳ\": \"DZ\",\n    \"Ǆ\": \"DZ\",\n    \"É\": \"E\",\n    \"Ĕ\": \"E\",\n    \"Ě\": \"E\",\n    \"Ȩ\": \"E\",\n    \"Ḝ\": \"E\",\n    \"Ê\": \"E\",\n    \"Ế\": \"E\",\n    \"Ệ\": \"E\",\n    \"Ề\": \"E\",\n    \"Ể\": \"E\",\n    \"Ễ\": \"E\",\n    \"Ḙ\": \"E\",\n    \"Ë\": \"E\",\n    \"Ė\": \"E\",\n    \"Ẹ\": \"E\",\n    \"Ȅ\": \"E\",\n    \"È\": \"E\",\n    \"Ẻ\": \"E\",\n    \"Ȇ\": \"E\",\n    \"Ē\": \"E\",\n    \"Ḗ\": \"E\",\n    \"Ḕ\": \"E\",\n    \"Ę\": \"E\",\n    \"Ɇ\": \"E\",\n    \"Ẽ\": \"E\",\n    \"Ḛ\": \"E\",\n    \"Ꝫ\": \"ET\",\n    \"Ḟ\": \"F\",\n    \"Ƒ\": \"F\",\n    \"Ǵ\": \"G\",\n    \"Ğ\": \"G\",\n    \"Ǧ\": \"G\",\n    \"Ģ\": \"G\",\n    \"Ĝ\": \"G\",\n    \"Ġ\": \"G\",\n    \"Ɠ\": \"G\",\n    \"Ḡ\": \"G\",\n    \"Ǥ\": \"G\",\n    \"Ḫ\": \"H\",\n    \"Ȟ\": \"H\",\n    \"Ḩ\": \"H\",\n    \"Ĥ\": \"H\",\n    \"Ⱨ\": \"H\",\n    \"Ḧ\": \"H\",\n    \"Ḣ\": \"H\",\n    \"Ḥ\": \"H\",\n    \"Ħ\": \"H\",\n    \"Í\": \"I\",\n    \"Ĭ\": \"I\",\n    \"Ǐ\": \"I\",\n    \"Î\": \"I\",\n    \"Ï\": \"I\",\n    \"Ḯ\": \"I\",\n    \"İ\": \"I\",\n    \"Ị\": \"I\",\n    \"Ȉ\": \"I\",\n    \"Ì\": \"I\",\n    \"Ỉ\": \"I\",\n    \"Ȋ\": \"I\",\n    \"Ī\": \"I\",\n    \"Į\": \"I\",\n    \"Ɨ\": \"I\",\n    \"Ĩ\": \"I\",\n    \"Ḭ\": \"I\",\n    \"Ꝺ\": \"D\",\n    \"Ꝼ\": \"F\",\n    \"Ᵹ\": \"G\",\n    \"Ꞃ\": \"R\",\n    \"Ꞅ\": \"S\",\n    \"Ꞇ\": \"T\",\n    \"Ꝭ\": \"IS\",\n    \"Ĵ\": \"J\",\n    \"Ɉ\": \"J\",\n    \"Ḱ\": \"K\",\n    \"Ǩ\": \"K\",\n    \"Ķ\": \"K\",\n    \"Ⱪ\": \"K\",\n    \"Ꝃ\": \"K\",\n    \"Ḳ\": \"K\",\n    \"Ƙ\": \"K\",\n    \"Ḵ\": \"K\",\n    \"Ꝁ\": \"K\",\n    \"Ꝅ\": \"K\",\n    \"Ĺ\": \"L\",\n    \"Ƚ\": \"L\",\n    \"Ľ\": \"L\",\n    \"Ļ\": \"L\",\n    \"Ḽ\": \"L\",\n    \"Ḷ\": \"L\",\n    \"Ḹ\": \"L\",\n    \"Ⱡ\": \"L\",\n    \"Ꝉ\": \"L\",\n    \"Ḻ\": \"L\",\n    \"Ŀ\": \"L\",\n    \"Ɫ\": \"L\",\n    \"ǈ\": \"L\",\n    \"Ł\": \"L\",\n    \"Ǉ\": \"LJ\",\n    \"Ḿ\": \"M\",\n    \"Ṁ\": \"M\",\n    \"Ṃ\": \"M\",\n    \"Ɱ\": \"M\",\n    \"Ń\": \"N\",\n    \"Ň\": \"N\",\n    \"Ņ\": \"N\",\n    \"Ṋ\": \"N\",\n    \"Ṅ\": \"N\",\n    \"Ṇ\": \"N\",\n    \"Ǹ\": \"N\",\n    \"Ɲ\": \"N\",\n    \"Ṉ\": \"N\",\n    \"Ƞ\": \"N\",\n    \"ǋ\": \"N\",\n    \"Ñ\": \"N\",\n    \"Ǌ\": \"NJ\",\n    \"Ó\": \"O\",\n    \"Ŏ\": \"O\",\n    \"Ǒ\": \"O\",\n    \"Ô\": \"O\",\n    \"Ố\": \"O\",\n    \"Ộ\": \"O\",\n    \"Ồ\": \"O\",\n    \"Ổ\": \"O\",\n    \"Ỗ\": \"O\",\n    \"Ö\": \"O\",\n    \"Ȫ\": \"O\",\n    \"Ȯ\": \"O\",\n    \"Ȱ\": \"O\",\n    \"Ọ\": \"O\",\n    \"Ő\": \"O\",\n    \"Ȍ\": \"O\",\n    \"Ò\": \"O\",\n    \"Ỏ\": \"O\",\n    \"Ơ\": \"O\",\n    \"Ớ\": \"O\",\n    \"Ợ\": \"O\",\n    \"Ờ\": \"O\",\n    \"Ở\": \"O\",\n    \"Ỡ\": \"O\",\n    \"Ȏ\": \"O\",\n    \"Ꝋ\": \"O\",\n    \"Ꝍ\": \"O\",\n    \"Ō\": \"O\",\n    \"Ṓ\": \"O\",\n    \"Ṑ\": \"O\",\n    \"Ɵ\": \"O\",\n    \"Ǫ\": \"O\",\n    \"Ǭ\": \"O\",\n    \"Ø\": \"O\",\n    \"Ǿ\": \"O\",\n    \"Õ\": \"O\",\n    \"Ṍ\": \"O\",\n    \"Ṏ\": \"O\",\n    \"Ȭ\": \"O\",\n    \"Ƣ\": \"OI\",\n    \"Ꝏ\": \"OO\",\n    \"Ɛ\": \"E\",\n    \"Ɔ\": \"O\",\n    \"Ȣ\": \"OU\",\n    \"Ṕ\": \"P\",\n    \"Ṗ\": \"P\",\n    \"Ꝓ\": \"P\",\n    \"Ƥ\": \"P\",\n    \"Ꝕ\": \"P\",\n    \"Ᵽ\": \"P\",\n    \"Ꝑ\": \"P\",\n    \"Ꝙ\": \"Q\",\n    \"Ꝗ\": \"Q\",\n    \"Ŕ\": \"R\",\n    \"Ř\": \"R\",\n    \"Ŗ\": \"R\",\n    \"Ṙ\": \"R\",\n    \"Ṛ\": \"R\",\n    \"Ṝ\": \"R\",\n    \"Ȑ\": \"R\",\n    \"Ȓ\": \"R\",\n    \"Ṟ\": \"R\",\n    \"Ɍ\": \"R\",\n    \"Ɽ\": \"R\",\n    \"Ꜿ\": \"C\",\n    \"Ǝ\": \"E\",\n    \"Ś\": \"S\",\n    \"Ṥ\": \"S\",\n    \"Š\": \"S\",\n    \"Ṧ\": \"S\",\n    \"Ş\": \"S\",\n    \"Ŝ\": \"S\",\n    \"Ș\": \"S\",\n    \"Ṡ\": \"S\",\n    \"Ṣ\": \"S\",\n    \"Ṩ\": \"S\",\n    \"ẞ\": \"SS\",\n    \"Ť\": \"T\",\n    \"Ţ\": \"T\",\n    \"Ṱ\": \"T\",\n    \"Ț\": \"T\",\n    \"Ⱦ\": \"T\",\n    \"Ṫ\": \"T\",\n    \"Ṭ\": \"T\",\n    \"Ƭ\": \"T\",\n    \"Ṯ\": \"T\",\n    \"Ʈ\": \"T\",\n    \"Ŧ\": \"T\",\n    \"Ɐ\": \"A\",\n    \"Ꞁ\": \"L\",\n    \"Ɯ\": \"M\",\n    \"Ʌ\": \"V\",\n    \"Ꜩ\": \"TZ\",\n    \"Ú\": \"U\",\n    \"Ŭ\": \"U\",\n    \"Ǔ\": \"U\",\n    \"Û\": \"U\",\n    \"Ṷ\": \"U\",\n    \"Ü\": \"U\",\n    \"Ǘ\": \"U\",\n    \"Ǚ\": \"U\",\n    \"Ǜ\": \"U\",\n    \"Ǖ\": \"U\",\n    \"Ṳ\": \"U\",\n    \"Ụ\": \"U\",\n    \"Ű\": \"U\",\n    \"Ȕ\": \"U\",\n    \"Ù\": \"U\",\n    \"Ủ\": \"U\",\n    \"Ư\": \"U\",\n    \"Ứ\": \"U\",\n    \"Ự\": \"U\",\n    \"Ừ\": \"U\",\n    \"Ử\": \"U\",\n    \"Ữ\": \"U\",\n    \"Ȗ\": \"U\",\n    \"Ū\": \"U\",\n    \"Ṻ\": \"U\",\n    \"Ų\": \"U\",\n    \"Ů\": \"U\",\n    \"Ũ\": \"U\",\n    \"Ṹ\": \"U\",\n    \"Ṵ\": \"U\",\n    \"Ꝟ\": \"V\",\n    \"Ṿ\": \"V\",\n    \"Ʋ\": \"V\",\n    \"Ṽ\": \"V\",\n    \"Ꝡ\": \"VY\",\n    \"Ẃ\": \"W\",\n    \"Ŵ\": \"W\",\n    \"Ẅ\": \"W\",\n    \"Ẇ\": \"W\",\n    \"Ẉ\": \"W\",\n    \"Ẁ\": \"W\",\n    \"Ⱳ\": \"W\",\n    \"Ẍ\": \"X\",\n    \"Ẋ\": \"X\",\n    \"Ý\": \"Y\",\n    \"Ŷ\": \"Y\",\n    \"Ÿ\": \"Y\",\n    \"Ẏ\": \"Y\",\n    \"Ỵ\": \"Y\",\n    \"Ỳ\": \"Y\",\n    \"Ƴ\": \"Y\",\n    \"Ỷ\": \"Y\",\n    \"Ỿ\": \"Y\",\n    \"Ȳ\": \"Y\",\n    \"Ɏ\": \"Y\",\n    \"Ỹ\": \"Y\",\n    \"Ź\": \"Z\",\n    \"Ž\": \"Z\",\n    \"Ẑ\": \"Z\",\n    \"Ⱬ\": \"Z\",\n    \"Ż\": \"Z\",\n    \"Ẓ\": \"Z\",\n    \"Ȥ\": \"Z\",\n    \"Ẕ\": \"Z\",\n    \"Ƶ\": \"Z\",\n    \"Ĳ\": \"IJ\",\n    \"Œ\": \"OE\",\n    \"ᴀ\": \"A\",\n    \"ᴁ\": \"AE\",\n    \"ʙ\": \"B\",\n    \"ᴃ\": \"B\",\n    \"ᴄ\": \"C\",\n    \"ᴅ\": \"D\",\n    \"ᴇ\": \"E\",\n    \"ꜰ\": \"F\",\n    \"ɢ\": \"G\",\n    \"ʛ\": \"G\",\n    \"ʜ\": \"H\",\n    \"ɪ\": \"I\",\n    \"ʁ\": \"R\",\n    \"ᴊ\": \"J\",\n    \"ᴋ\": \"K\",\n    \"ʟ\": \"L\",\n    \"ᴌ\": \"L\",\n    \"ᴍ\": \"M\",\n    \"ɴ\": \"N\",\n    \"ᴏ\": \"O\",\n    \"ɶ\": \"OE\",\n    \"ᴐ\": \"O\",\n    \"ᴕ\": \"OU\",\n    \"ᴘ\": \"P\",\n    \"ʀ\": \"R\",\n    \"ᴎ\": \"N\",\n    \"ᴙ\": \"R\",\n    \"ꜱ\": \"S\",\n    \"ᴛ\": \"T\",\n    \"ⱻ\": \"E\",\n    \"ᴚ\": \"R\",\n    \"ᴜ\": \"U\",\n    \"ᴠ\": \"V\",\n    \"ᴡ\": \"W\",\n    \"ʏ\": \"Y\",\n    \"ᴢ\": \"Z\",\n    \"á\": \"a\",\n    \"ă\": \"a\",\n    \"ắ\": \"a\",\n    \"ặ\": \"a\",\n    \"ằ\": \"a\",\n    \"ẳ\": \"a\",\n    \"ẵ\": \"a\",\n    \"ǎ\": \"a\",\n    \"â\": \"a\",\n    \"ấ\": \"a\",\n    \"ậ\": \"a\",\n    \"ầ\": \"a\",\n    \"ẩ\": \"a\",\n    \"ẫ\": \"a\",\n    \"ä\": \"a\",\n    \"ǟ\": \"a\",\n    \"ȧ\": \"a\",\n    \"ǡ\": \"a\",\n    \"ạ\": \"a\",\n    \"ȁ\": \"a\",\n    \"à\": \"a\",\n    \"ả\": \"a\",\n    \"ȃ\": \"a\",\n    \"ā\": \"a\",\n    \"ą\": \"a\",\n    \"ᶏ\": \"a\",\n    \"ẚ\": \"a\",\n    \"å\": \"a\",\n    \"ǻ\": \"a\",\n    \"ḁ\": \"a\",\n    \"ⱥ\": \"a\",\n    \"ã\": \"a\",\n    \"ꜳ\": \"aa\",\n    \"æ\": \"ae\",\n    \"ǽ\": \"ae\",\n    \"ǣ\": \"ae\",\n    \"ꜵ\": \"ao\",\n    \"ꜷ\": \"au\",\n    \"ꜹ\": \"av\",\n    \"ꜻ\": \"av\",\n    \"ꜽ\": \"ay\",\n    \"ḃ\": \"b\",\n    \"ḅ\": \"b\",\n    \"ɓ\": \"b\",\n    \"ḇ\": \"b\",\n    \"ᵬ\": \"b\",\n    \"ᶀ\": \"b\",\n    \"ƀ\": \"b\",\n    \"ƃ\": \"b\",\n    \"ɵ\": \"o\",\n    \"ć\": \"c\",\n    \"č\": \"c\",\n    \"ç\": \"c\",\n    \"ḉ\": \"c\",\n    \"ĉ\": \"c\",\n    \"ɕ\": \"c\",\n    \"ċ\": \"c\",\n    \"ƈ\": \"c\",\n    \"ȼ\": \"c\",\n    \"ď\": \"d\",\n    \"ḑ\": \"d\",\n    \"ḓ\": \"d\",\n    \"ȡ\": \"d\",\n    \"ḋ\": \"d\",\n    \"ḍ\": \"d\",\n    \"ɗ\": \"d\",\n    \"ᶑ\": \"d\",\n    \"ḏ\": \"d\",\n    \"ᵭ\": \"d\",\n    \"ᶁ\": \"d\",\n    \"đ\": \"d\",\n    \"ɖ\": \"d\",\n    \"ƌ\": \"d\",\n    \"ı\": \"i\",\n    \"ȷ\": \"j\",\n    \"ɟ\": \"j\",\n    \"ʄ\": \"j\",\n    \"ǳ\": \"dz\",\n    \"ǆ\": \"dz\",\n    \"é\": \"e\",\n    \"ĕ\": \"e\",\n    \"ě\": \"e\",\n    \"ȩ\": \"e\",\n    \"ḝ\": \"e\",\n    \"ê\": \"e\",\n    \"ế\": \"e\",\n    \"ệ\": \"e\",\n    \"ề\": \"e\",\n    \"ể\": \"e\",\n    \"ễ\": \"e\",\n    \"ḙ\": \"e\",\n    \"ë\": \"e\",\n    \"ė\": \"e\",\n    \"ẹ\": \"e\",\n    \"ȅ\": \"e\",\n    \"è\": \"e\",\n    \"ẻ\": \"e\",\n    \"ȇ\": \"e\",\n    \"ē\": \"e\",\n    \"ḗ\": \"e\",\n    \"ḕ\": \"e\",\n    \"ⱸ\": \"e\",\n    \"ę\": \"e\",\n    \"ᶒ\": \"e\",\n    \"ɇ\": \"e\",\n    \"ẽ\": \"e\",\n    \"ḛ\": \"e\",\n    \"ꝫ\": \"et\",\n    \"ḟ\": \"f\",\n    \"ƒ\": \"f\",\n    \"ᵮ\": \"f\",\n    \"ᶂ\": \"f\",\n    \"ǵ\": \"g\",\n    \"ğ\": \"g\",\n    \"ǧ\": \"g\",\n    \"ģ\": \"g\",\n    \"ĝ\": \"g\",\n    \"ġ\": \"g\",\n    \"ɠ\": \"g\",\n    \"ḡ\": \"g\",\n    \"ᶃ\": \"g\",\n    \"ǥ\": \"g\",\n    \"ḫ\": \"h\",\n    \"ȟ\": \"h\",\n    \"ḩ\": \"h\",\n    \"ĥ\": \"h\",\n    \"ⱨ\": \"h\",\n    \"ḧ\": \"h\",\n    \"ḣ\": \"h\",\n    \"ḥ\": \"h\",\n    \"ɦ\": \"h\",\n    \"ẖ\": \"h\",\n    \"ħ\": \"h\",\n    \"ƕ\": \"hv\",\n    \"í\": \"i\",\n    \"ĭ\": \"i\",\n    \"ǐ\": \"i\",\n    \"î\": \"i\",\n    \"ï\": \"i\",\n    \"ḯ\": \"i\",\n    \"ị\": \"i\",\n    \"ȉ\": \"i\",\n    \"ì\": \"i\",\n    \"ỉ\": \"i\",\n    \"ȋ\": \"i\",\n    \"ī\": \"i\",\n    \"į\": \"i\",\n    \"ᶖ\": \"i\",\n    \"ɨ\": \"i\",\n    \"ĩ\": \"i\",\n    \"ḭ\": \"i\",\n    \"ꝺ\": \"d\",\n    \"ꝼ\": \"f\",\n    \"ᵹ\": \"g\",\n    \"ꞃ\": \"r\",\n    \"ꞅ\": \"s\",\n    \"ꞇ\": \"t\",\n    \"ꝭ\": \"is\",\n    \"ǰ\": \"j\",\n    \"ĵ\": \"j\",\n    \"ʝ\": \"j\",\n    \"ɉ\": \"j\",\n    \"ḱ\": \"k\",\n    \"ǩ\": \"k\",\n    \"ķ\": \"k\",\n    \"ⱪ\": \"k\",\n    \"ꝃ\": \"k\",\n    \"ḳ\": \"k\",\n    \"ƙ\": \"k\",\n    \"ḵ\": \"k\",\n    \"ᶄ\": \"k\",\n    \"ꝁ\": \"k\",\n    \"ꝅ\": \"k\",\n    \"ĺ\": \"l\",\n    \"ƚ\": \"l\",\n    \"ɬ\": \"l\",\n    \"ľ\": \"l\",\n    \"ļ\": \"l\",\n    \"ḽ\": \"l\",\n    \"ȴ\": \"l\",\n    \"ḷ\": \"l\",\n    \"ḹ\": \"l\",\n    \"ⱡ\": \"l\",\n    \"ꝉ\": \"l\",\n    \"ḻ\": \"l\",\n    \"ŀ\": \"l\",\n    \"ɫ\": \"l\",\n    \"ᶅ\": \"l\",\n    \"ɭ\": \"l\",\n    \"ł\": \"l\",\n    \"ǉ\": \"lj\",\n    \"ſ\": \"s\",\n    \"ẜ\": \"s\",\n    \"ẛ\": \"s\",\n    \"ẝ\": \"s\",\n    \"ḿ\": \"m\",\n    \"ṁ\": \"m\",\n    \"ṃ\": \"m\",\n    \"ɱ\": \"m\",\n    \"ᵯ\": \"m\",\n    \"ᶆ\": \"m\",\n    \"ń\": \"n\",\n    \"ň\": \"n\",\n    \"ņ\": \"n\",\n    \"ṋ\": \"n\",\n    \"ȵ\": \"n\",\n    \"ṅ\": \"n\",\n    \"ṇ\": \"n\",\n    \"ǹ\": \"n\",\n    \"ɲ\": \"n\",\n    \"ṉ\": \"n\",\n    \"ƞ\": \"n\",\n    \"ᵰ\": \"n\",\n    \"ᶇ\": \"n\",\n    \"ɳ\": \"n\",\n    \"ñ\": \"n\",\n    \"ǌ\": \"nj\",\n    \"ó\": \"o\",\n    \"ŏ\": \"o\",\n    \"ǒ\": \"o\",\n    \"ô\": \"o\",\n    \"ố\": \"o\",\n    \"ộ\": \"o\",\n    \"ồ\": \"o\",\n    \"ổ\": \"o\",\n    \"ỗ\": \"o\",\n    \"ö\": \"o\",\n    \"ȫ\": \"o\",\n    \"ȯ\": \"o\",\n    \"ȱ\": \"o\",\n    \"ọ\": \"o\",\n    \"ő\": \"o\",\n    \"ȍ\": \"o\",\n    \"ò\": \"o\",\n    \"ỏ\": \"o\",\n    \"ơ\": \"o\",\n    \"ớ\": \"o\",\n    \"ợ\": \"o\",\n    \"ờ\": \"o\",\n    \"ở\": \"o\",\n    \"ỡ\": \"o\",\n    \"ȏ\": \"o\",\n    \"ꝋ\": \"o\",\n    \"ꝍ\": \"o\",\n    \"ⱺ\": \"o\",\n    \"ō\": \"o\",\n    \"ṓ\": \"o\",\n    \"ṑ\": \"o\",\n    \"ǫ\": \"o\",\n    \"ǭ\": \"o\",\n    \"ø\": \"o\",\n    \"ǿ\": \"o\",\n    \"õ\": \"o\",\n    \"ṍ\": \"o\",\n    \"ṏ\": \"o\",\n    \"ȭ\": \"o\",\n    \"ƣ\": \"oi\",\n    \"ꝏ\": \"oo\",\n    \"ɛ\": \"e\",\n    \"ᶓ\": \"e\",\n    \"ɔ\": \"o\",\n    \"ᶗ\": \"o\",\n    \"ȣ\": \"ou\",\n    \"ṕ\": \"p\",\n    \"ṗ\": \"p\",\n    \"ꝓ\": \"p\",\n    \"ƥ\": \"p\",\n    \"ᵱ\": \"p\",\n    \"ᶈ\": \"p\",\n    \"ꝕ\": \"p\",\n    \"ᵽ\": \"p\",\n    \"ꝑ\": \"p\",\n    \"ꝙ\": \"q\",\n    \"ʠ\": \"q\",\n    \"ɋ\": \"q\",\n    \"ꝗ\": \"q\",\n    \"ŕ\": \"r\",\n    \"ř\": \"r\",\n    \"ŗ\": \"r\",\n    \"ṙ\": \"r\",\n    \"ṛ\": \"r\",\n    \"ṝ\": \"r\",\n    \"ȑ\": \"r\",\n    \"ɾ\": \"r\",\n    \"ᵳ\": \"r\",\n    \"ȓ\": \"r\",\n    \"ṟ\": \"r\",\n    \"ɼ\": \"r\",\n    \"ᵲ\": \"r\",\n    \"ᶉ\": \"r\",\n    \"ɍ\": \"r\",\n    \"ɽ\": \"r\",\n    \"ↄ\": \"c\",\n    \"ꜿ\": \"c\",\n    \"ɘ\": \"e\",\n    \"ɿ\": \"r\",\n    \"ś\": \"s\",\n    \"ṥ\": \"s\",\n    \"š\": \"s\",\n    \"ṧ\": \"s\",\n    \"ş\": \"s\",\n    \"ŝ\": \"s\",\n    \"ș\": \"s\",\n    \"ṡ\": \"s\",\n    \"ṣ\": \"s\",\n    \"ṩ\": \"s\",\n    \"ʂ\": \"s\",\n    \"ᵴ\": \"s\",\n    \"ᶊ\": \"s\",\n    \"ȿ\": \"s\",\n    \"ɡ\": \"g\",\n    \"ß\": \"ss\",\n    \"ᴑ\": \"o\",\n    \"ᴓ\": \"o\",\n    \"ᴝ\": \"u\",\n    \"ť\": \"t\",\n    \"ţ\": \"t\",\n    \"ṱ\": \"t\",\n    \"ț\": \"t\",\n    \"ȶ\": \"t\",\n    \"ẗ\": \"t\",\n    \"ⱦ\": \"t\",\n    \"ṫ\": \"t\",\n    \"ṭ\": \"t\",\n    \"ƭ\": \"t\",\n    \"ṯ\": \"t\",\n    \"ᵵ\": \"t\",\n    \"ƫ\": \"t\",\n    \"ʈ\": \"t\",\n    \"ŧ\": \"t\",\n    \"ᵺ\": \"th\",\n    \"ɐ\": \"a\",\n    \"ᴂ\": \"ae\",\n    \"ǝ\": \"e\",\n    \"ᵷ\": \"g\",\n    \"ɥ\": \"h\",\n    \"ʮ\": \"h\",\n    \"ʯ\": \"h\",\n    \"ᴉ\": \"i\",\n    \"ʞ\": \"k\",\n    \"ꞁ\": \"l\",\n    \"ɯ\": \"m\",\n    \"ɰ\": \"m\",\n    \"ᴔ\": \"oe\",\n    \"ɹ\": \"r\",\n    \"ɻ\": \"r\",\n    \"ɺ\": \"r\",\n    \"ⱹ\": \"r\",\n    \"ʇ\": \"t\",\n    \"ʌ\": \"v\",\n    \"ʍ\": \"w\",\n    \"ʎ\": \"y\",\n    \"ꜩ\": \"tz\",\n    \"ú\": \"u\",\n    \"ŭ\": \"u\",\n    \"ǔ\": \"u\",\n    \"û\": \"u\",\n    \"ṷ\": \"u\",\n    \"ü\": \"u\",\n    \"ǘ\": \"u\",\n    \"ǚ\": \"u\",\n    \"ǜ\": \"u\",\n    \"ǖ\": \"u\",\n    \"ṳ\": \"u\",\n    \"ụ\": \"u\",\n    \"ű\": \"u\",\n    \"ȕ\": \"u\",\n    \"ù\": \"u\",\n    \"ủ\": \"u\",\n    \"ư\": \"u\",\n    \"ứ\": \"u\",\n    \"ự\": \"u\",\n    \"ừ\": \"u\",\n    \"ử\": \"u\",\n    \"ữ\": \"u\",\n    \"ȗ\": \"u\",\n    \"ū\": \"u\",\n    \"ṻ\": \"u\",\n    \"ų\": \"u\",\n    \"ᶙ\": \"u\",\n    \"ů\": \"u\",\n    \"ũ\": \"u\",\n    \"ṹ\": \"u\",\n    \"ṵ\": \"u\",\n    \"ᵫ\": \"ue\",\n    \"ꝸ\": \"um\",\n    \"ⱴ\": \"v\",\n    \"ꝟ\": \"v\",\n    \"ṿ\": \"v\",\n    \"ʋ\": \"v\",\n    \"ᶌ\": \"v\",\n    \"ⱱ\": \"v\",\n    \"ṽ\": \"v\",\n    \"ꝡ\": \"vy\",\n    \"ẃ\": \"w\",\n    \"ŵ\": \"w\",\n    \"ẅ\": \"w\",\n    \"ẇ\": \"w\",\n    \"ẉ\": \"w\",\n    \"ẁ\": \"w\",\n    \"ⱳ\": \"w\",\n    \"ẘ\": \"w\",\n    \"ẍ\": \"x\",\n    \"ẋ\": \"x\",\n    \"ᶍ\": \"x\",\n    \"ý\": \"y\",\n    \"ŷ\": \"y\",\n    \"ÿ\": \"y\",\n    \"ẏ\": \"y\",\n    \"ỵ\": \"y\",\n    \"ỳ\": \"y\",\n    \"ƴ\": \"y\",\n    \"ỷ\": \"y\",\n    \"ỿ\": \"y\",\n    \"ȳ\": \"y\",\n    \"ẙ\": \"y\",\n    \"ɏ\": \"y\",\n    \"ỹ\": \"y\",\n    \"ź\": \"z\",\n    \"ž\": \"z\",\n    \"ẑ\": \"z\",\n    \"ʑ\": \"z\",\n    \"ⱬ\": \"z\",\n    \"ż\": \"z\",\n    \"ẓ\": \"z\",\n    \"ȥ\": \"z\",\n    \"ẕ\": \"z\",\n    \"ᵶ\": \"z\",\n    \"ᶎ\": \"z\",\n    \"ʐ\": \"z\",\n    \"ƶ\": \"z\",\n    \"ɀ\": \"z\",\n    \"ﬀ\": \"ff\",\n    \"ﬃ\": \"ffi\",\n    \"ﬄ\": \"ffl\",\n    \"ﬁ\": \"fi\",\n    \"ﬂ\": \"fl\",\n    \"ĳ\": \"ij\",\n    \"œ\": \"oe\",\n    \"ﬆ\": \"st\",\n    \"ₐ\": \"a\",\n    \"ₑ\": \"e\",\n    \"ᵢ\": \"i\",\n    \"ⱼ\": \"j\",\n    \"ₒ\": \"o\",\n    \"ᵣ\": \"r\",\n    \"ᵤ\": \"u\",\n    \"ᵥ\": \"v\",\n    \"ₓ\": \"x\"\n  }; //******************************************************************************\n  // Added an initialize function which is essentially the code from the S\n  // constructor.  Now, the S constructor calls this and a new method named\n  // setValue calls it as well.  The setValue function allows constructors for\n  // modules that extend string.js to set the initial value of an object without\n  // knowing the internal workings of string.js.\n  //\n  // Also, all methods which return a new S object now call:\n  //\n  //      return new this.constructor(s);\n  //\n  // instead of:\n  //\n  //      return new S(s);\n  //\n  // This allows extended objects to keep their proper instanceOf and constructor.\n  //******************************************************************************\n\n  function initialize(object, s) {\n    if (s !== null && s !== undefined) {\n      if (typeof s === 'string') object.s = s;else object.s = s.toString();\n    } else {\n      object.s = s; //null or undefined\n    }\n\n    object.orig = s; //original object, currently only used by toCSV() and toBoolean()\n\n    if (s !== null && s !== undefined) {\n      if (object.__defineGetter__) {\n        object.__defineGetter__('length', function () {\n          return object.s.length;\n        });\n      } else {\n        object.length = s.length;\n      }\n    } else {\n      object.length = -1;\n    }\n  }\n\n  function S(s) {\n    initialize(this, s);\n  }\n\n  var __nsp = String.prototype;\n\n  var __sp = S.prototype = {\n    between: function (left, right) {\n      var s = this.s;\n      var startPos = s.indexOf(left);\n      var endPos = s.indexOf(right, startPos + left.length);\n      if (endPos == -1 && right != null) return new this.constructor('');else if (endPos == -1 && right == null) return new this.constructor(s.substring(startPos + left.length));else return new this.constructor(s.slice(startPos + left.length, endPos));\n    },\n    //# modified slightly from https://github.com/epeli/underscore.string\n    camelize: function () {\n      var s = this.trim().s.replace(/(\\-|_|\\s)+(.)?/g, function (mathc, sep, c) {\n        return c ? c.toUpperCase() : '';\n      });\n      return new this.constructor(s);\n    },\n    capitalize: function () {\n      return new this.constructor(this.s.substr(0, 1).toUpperCase() + this.s.substring(1).toLowerCase());\n    },\n    charAt: function (index) {\n      return this.s.charAt(index);\n    },\n    chompLeft: function (prefix) {\n      var s = this.s;\n\n      if (s.indexOf(prefix) === 0) {\n        s = s.slice(prefix.length);\n        return new this.constructor(s);\n      } else {\n        return this;\n      }\n    },\n    chompRight: function (suffix) {\n      if (this.endsWith(suffix)) {\n        var s = this.s;\n        s = s.slice(0, s.length - suffix.length);\n        return new this.constructor(s);\n      } else {\n        return this;\n      }\n    },\n    //#thanks Google\n    collapseWhitespace: function () {\n      var s = this.s.replace(/[\\s\\xa0]+/g, ' ').replace(/^\\s+|\\s+$/g, '');\n      return new this.constructor(s);\n    },\n    contains: function (ss) {\n      return this.s.indexOf(ss) >= 0;\n    },\n    count: function (ss) {\n      return require('./_count')(this.s, ss);\n    },\n    //#modified from https://github.com/epeli/underscore.string\n    dasherize: function () {\n      var s = this.trim().s.replace(/[_\\s]+/g, '-').replace(/([A-Z])/g, '-$1').replace(/-+/g, '-').toLowerCase();\n      return new this.constructor(s);\n    },\n    equalsIgnoreCase: function (prefix) {\n      var s = this.s;\n      return s.toLowerCase() == prefix.toLowerCase();\n    },\n    latinise: function () {\n      var s = this.replace(/[^A-Za-z0-9\\[\\] ]/g, function (x) {\n        return latin_map[x] || x;\n      });\n      return new this.constructor(s);\n    },\n    decodeHtmlEntities: function () {\n      //https://github.com/substack/node-ent/blob/master/index.js\n      var s = this.s;\n      s = s.replace(/&#(\\d+);?/g, function (_, code) {\n        return String.fromCharCode(code);\n      }).replace(/&#[xX]([A-Fa-f0-9]+);?/g, function (_, hex) {\n        return String.fromCharCode(parseInt(hex, 16));\n      }).replace(/&([^;\\W]+;?)/g, function (m, e) {\n        var ee = e.replace(/;$/, '');\n        var target = ENTITIES[e] || e.match(/;$/) && ENTITIES[ee];\n\n        if (typeof target === 'number') {\n          return String.fromCharCode(target);\n        } else if (typeof target === 'string') {\n          return target;\n        } else {\n          return m;\n        }\n      });\n      return new this.constructor(s);\n    },\n    endsWith: function () {\n      var suffixes = Array.prototype.slice.call(arguments, 0);\n\n      for (var i = 0; i < suffixes.length; ++i) {\n        var l = this.s.length - suffixes[i].length;\n        if (l >= 0 && this.s.indexOf(suffixes[i], l) === l) return true;\n      }\n\n      return false;\n    },\n    escapeHTML: function () {\n      //from underscore.string\n      return new this.constructor(this.s.replace(/[&<>\"']/g, function (m) {\n        return '&' + reversedEscapeChars[m] + ';';\n      }));\n    },\n    ensureLeft: function (prefix) {\n      var s = this.s;\n\n      if (s.indexOf(prefix) === 0) {\n        return this;\n      } else {\n        return new this.constructor(prefix + s);\n      }\n    },\n    ensureRight: function (suffix) {\n      var s = this.s;\n\n      if (this.endsWith(suffix)) {\n        return this;\n      } else {\n        return new this.constructor(s + suffix);\n      }\n    },\n    humanize: function () {\n      //modified from underscore.string\n      if (this.s === null || this.s === undefined) return new this.constructor('');\n      var s = this.underscore().replace(/_id$/, '').replace(/_/g, ' ').trim().capitalize();\n      return new this.constructor(s);\n    },\n    isAlpha: function () {\n      return !/[^a-z\\xDF-\\xFF]|^$/.test(this.s.toLowerCase());\n    },\n    isAlphaNumeric: function () {\n      return !/[^0-9a-z\\xDF-\\xFF]/.test(this.s.toLowerCase());\n    },\n    isEmpty: function () {\n      return this.s === null || this.s === undefined ? true : /^[\\s\\xa0]*$/.test(this.s);\n    },\n    isLower: function () {\n      return this.isAlpha() && this.s.toLowerCase() === this.s;\n    },\n    isNumeric: function () {\n      return !/[^0-9]/.test(this.s);\n    },\n    isUpper: function () {\n      return this.isAlpha() && this.s.toUpperCase() === this.s;\n    },\n    left: function (N) {\n      if (N >= 0) {\n        var s = this.s.substr(0, N);\n        return new this.constructor(s);\n      } else {\n        return this.right(-N);\n      }\n    },\n    lines: function () {\n      //convert windows newlines to unix newlines then convert to an Array of lines\n      return this.replaceAll('\\r\\n', '\\n').s.split('\\n');\n    },\n    pad: function (len, ch) {\n      //https://github.com/component/pad\n      if (ch == null) ch = ' ';\n      if (this.s.length >= len) return new this.constructor(this.s);\n      len = len - this.s.length;\n      var left = Array(Math.ceil(len / 2) + 1).join(ch);\n      var right = Array(Math.floor(len / 2) + 1).join(ch);\n      return new this.constructor(left + this.s + right);\n    },\n    padLeft: function (len, ch) {\n      //https://github.com/component/pad\n      if (ch == null) ch = ' ';\n      if (this.s.length >= len) return new this.constructor(this.s);\n      return new this.constructor(Array(len - this.s.length + 1).join(ch) + this.s);\n    },\n    padRight: function (len, ch) {\n      //https://github.com/component/pad\n      if (ch == null) ch = ' ';\n      if (this.s.length >= len) return new this.constructor(this.s);\n      return new this.constructor(this.s + Array(len - this.s.length + 1).join(ch));\n    },\n    parseCSV: function (delimiter, qualifier, escape, lineDelimiter) {\n      //try to parse no matter what\n      delimiter = delimiter || ',';\n      escape = escape || '\\\\';\n      if (typeof qualifier == 'undefined') qualifier = '\"';\n      var i = 0,\n          fieldBuffer = [],\n          fields = [],\n          len = this.s.length,\n          inField = false,\n          inUnqualifiedString = false,\n          self = this;\n\n      var ca = function (i) {\n        return self.s.charAt(i);\n      };\n\n      if (typeof lineDelimiter !== 'undefined') var rows = [];\n      if (!qualifier) inField = true;\n\n      while (i < len) {\n        var current = ca(i);\n\n        switch (current) {\n          case escape:\n            //fix for issues #32 and #35\n            if (inField && (escape !== qualifier || ca(i + 1) === qualifier)) {\n              i += 1;\n              fieldBuffer.push(ca(i));\n              break;\n            }\n\n            if (escape !== qualifier) break;\n\n          case qualifier:\n            inField = !inField;\n            break;\n\n          case delimiter:\n            if (inUnqualifiedString) {\n              inField = false;\n              inUnqualifiedString = false;\n            }\n\n            if (inField && qualifier) fieldBuffer.push(current);else {\n              fields.push(fieldBuffer.join(''));\n              fieldBuffer.length = 0;\n            }\n            break;\n\n          case lineDelimiter:\n            if (inUnqualifiedString) {\n              inField = false;\n              inUnqualifiedString = false;\n              fields.push(fieldBuffer.join(''));\n              rows.push(fields);\n              fields = [];\n              fieldBuffer.length = 0;\n            } else if (inField) {\n              fieldBuffer.push(current);\n            } else {\n              if (rows) {\n                fields.push(fieldBuffer.join(''));\n                rows.push(fields);\n                fields = [];\n                fieldBuffer.length = 0;\n              }\n            }\n\n            break;\n\n          case ' ':\n            if (inField) fieldBuffer.push(current);\n            break;\n\n          default:\n            if (inField) fieldBuffer.push(current);else if (current !== qualifier) {\n              fieldBuffer.push(current);\n              inField = true;\n              inUnqualifiedString = true;\n            }\n            break;\n        }\n\n        i += 1;\n      }\n\n      fields.push(fieldBuffer.join(''));\n\n      if (rows) {\n        rows.push(fields);\n        return rows;\n      }\n\n      return fields;\n    },\n    replaceAll: function (ss, r) {\n      //var s = this.s.replace(new RegExp(ss, 'g'), r);\n      var s = this.s.split(ss).join(r);\n      return new this.constructor(s);\n    },\n    splitLeft: function (sep, maxSplit, limit) {\n      return require('./_splitLeft')(this.s, sep, maxSplit, limit);\n    },\n    splitRight: function (sep, maxSplit, limit) {\n      return require('./_splitRight')(this.s, sep, maxSplit, limit);\n    },\n    strip: function () {\n      var ss = this.s;\n\n      for (var i = 0, n = arguments.length; i < n; i++) {\n        ss = ss.split(arguments[i]).join('');\n      }\n\n      return new this.constructor(ss);\n    },\n    stripLeft: function (chars) {\n      var regex;\n      var pattern;\n      var ss = ensureString(this.s);\n\n      if (chars === undefined) {\n        pattern = /^\\s+/g;\n      } else {\n        regex = escapeRegExp(chars);\n        pattern = new RegExp(\"^[\" + regex + \"]+\", \"g\");\n      }\n\n      return new this.constructor(ss.replace(pattern, \"\"));\n    },\n    stripRight: function (chars) {\n      var regex;\n      var pattern;\n      var ss = ensureString(this.s);\n\n      if (chars === undefined) {\n        pattern = /\\s+$/g;\n      } else {\n        regex = escapeRegExp(chars);\n        pattern = new RegExp(\"[\" + regex + \"]+$\", \"g\");\n      }\n\n      return new this.constructor(ss.replace(pattern, \"\"));\n    },\n    right: function (N) {\n      if (N >= 0) {\n        var s = this.s.substr(this.s.length - N, N);\n        return new this.constructor(s);\n      } else {\n        return this.left(-N);\n      }\n    },\n    setValue: function (s) {\n      initialize(this, s);\n      return this;\n    },\n    slugify: function () {\n      var sl = new S(new S(this.s).latinise().s.replace(/[^\\w\\s-]/g, '').toLowerCase()).dasherize().s;\n      if (sl.charAt(0) === '-') sl = sl.substr(1);\n      return new this.constructor(sl);\n    },\n    startsWith: function () {\n      var prefixes = Array.prototype.slice.call(arguments, 0);\n\n      for (var i = 0; i < prefixes.length; ++i) {\n        if (this.s.lastIndexOf(prefixes[i], 0) === 0) return true;\n      }\n\n      return false;\n    },\n    stripPunctuation: function () {\n      //return new this.constructor(this.s.replace(/[\\.,-\\/#!$%\\^&\\*;:{}=\\-_`~()]/g,\"\"));\n      return new this.constructor(this.s.replace(/[^\\w\\s]|_/g, \"\").replace(/\\s+/g, \" \"));\n    },\n    stripTags: function () {\n      //from sugar.js\n      var s = this.s,\n          args = arguments.length > 0 ? arguments : [''];\n      multiArgs(args, function (tag) {\n        s = s.replace(RegExp('<\\/?' + tag + '[^<>]*>', 'gi'), '');\n      });\n      return new this.constructor(s);\n    },\n    template: function (values, opening, closing) {\n      var s = this.s;\n      var opening = opening || Export.TMPL_OPEN;\n      var closing = closing || Export.TMPL_CLOSE;\n      var open = opening.replace(/[-[\\]()*\\s]/g, \"\\\\$&\").replace(/\\$/g, '\\\\$');\n      var close = closing.replace(/[-[\\]()*\\s]/g, \"\\\\$&\").replace(/\\$/g, '\\\\$');\n      var r = new RegExp(open + '(.+?)' + close, 'g'); //, r = /\\{\\{(.+?)\\}\\}/g\n\n      var matches = s.match(r) || [];\n      matches.forEach(function (match) {\n        var key = match.substring(opening.length, match.length - closing.length).trim(); //chop {{ and }}\n\n        var value = typeof values[key] == 'undefined' ? '' : values[key];\n        s = s.replace(match, value);\n      });\n      return new this.constructor(s);\n    },\n    times: function (n) {\n      return new this.constructor(new Array(n + 1).join(this.s));\n    },\n    titleCase: function () {\n      var s = this.s;\n\n      if (s) {\n        s = s.replace(/(^[a-z]| [a-z]|-[a-z]|_[a-z])/g, function ($1) {\n          return $1.toUpperCase();\n        });\n      }\n\n      return new this.constructor(s);\n    },\n    toBoolean: function () {\n      if (typeof this.orig === 'string') {\n        var s = this.s.toLowerCase();\n        return s === 'true' || s === 'yes' || s === 'on' || s === '1';\n      } else return this.orig === true || this.orig === 1;\n    },\n    toFloat: function (precision) {\n      var num = parseFloat(this.s);\n      if (precision) return parseFloat(num.toFixed(precision));else return num;\n    },\n    toInt: function () {\n      //thanks Google\n      // If the string starts with '0x' or '-0x', parse as hex.\n      return /^\\s*-?0x/i.test(this.s) ? parseInt(this.s, 16) : parseInt(this.s, 10);\n    },\n    trim: function () {\n      var s;\n      if (typeof __nsp.trim === 'undefined') s = this.s.replace(/(^\\s*|\\s*$)/g, '');else s = this.s.trim();\n      return new this.constructor(s);\n    },\n    trimLeft: function () {\n      var s;\n      if (__nsp.trimLeft) s = this.s.trimLeft();else s = this.s.replace(/(^\\s*)/g, '');\n      return new this.constructor(s);\n    },\n    trimRight: function () {\n      var s;\n      if (__nsp.trimRight) s = this.s.trimRight();else s = this.s.replace(/\\s+$/, '');\n      return new this.constructor(s);\n    },\n    truncate: function (length, pruneStr) {\n      //from underscore.string, author: github.com/rwz\n      var str = this.s;\n      length = ~~length;\n      pruneStr = pruneStr || '...';\n      if (str.length <= length) return new this.constructor(str);\n\n      var tmpl = function (c) {\n        return c.toUpperCase() !== c.toLowerCase() ? 'A' : ' ';\n      },\n          template = str.slice(0, length + 1).replace(/.(?=\\W*\\w*$)/g, tmpl); // 'Hello, world' -> 'HellAA AAAAA'\n\n\n      if (template.slice(template.length - 2).match(/\\w\\w/)) template = template.replace(/\\s*\\S+$/, '');else template = new S(template.slice(0, template.length - 1)).trimRight().s;\n      return (template + pruneStr).length > str.length ? new S(str) : new S(str.slice(0, template.length) + pruneStr);\n    },\n    toCSV: function () {\n      var delim = ',',\n          qualifier = '\"',\n          escape = '\\\\',\n          encloseNumbers = true,\n          keys = false;\n      var dataArray = [];\n\n      function hasVal(it) {\n        return it !== null && it !== '';\n      }\n\n      if (typeof arguments[0] === 'object') {\n        delim = arguments[0].delimiter || delim;\n        delim = arguments[0].separator || delim;\n        qualifier = arguments[0].qualifier || qualifier;\n        encloseNumbers = !!arguments[0].encloseNumbers;\n        escape = arguments[0].escape || escape;\n        keys = !!arguments[0].keys;\n      } else if (typeof arguments[0] === 'string') {\n        delim = arguments[0];\n      }\n\n      if (typeof arguments[1] === 'string') qualifier = arguments[1];\n      if (arguments[1] === null) qualifier = null;\n      if (this.orig instanceof Array) dataArray = this.orig;else {\n        //object\n        for (var key in this.orig) if (this.orig.hasOwnProperty(key)) if (keys) dataArray.push(key);else dataArray.push(this.orig[key]);\n      }\n      var rep = escape + qualifier;\n      var buildString = [];\n\n      for (var i = 0; i < dataArray.length; ++i) {\n        var shouldQualify = hasVal(qualifier);\n        if (typeof dataArray[i] == 'number') shouldQualify &= encloseNumbers;\n        if (shouldQualify) buildString.push(qualifier);\n\n        if (dataArray[i] !== null && dataArray[i] !== undefined) {\n          var d = new S(dataArray[i]).replaceAll(qualifier, rep).s;\n          buildString.push(d);\n        } else buildString.push('');\n\n        if (shouldQualify) buildString.push(qualifier);\n        if (delim) buildString.push(delim);\n      } //chop last delim\n      //console.log(buildString.length)\n\n\n      buildString.length = buildString.length - 1;\n      return new this.constructor(buildString.join(''));\n    },\n    toString: function () {\n      return this.s;\n    },\n    //#modified from https://github.com/epeli/underscore.string\n    underscore: function () {\n      var s = this.trim().s.replace(/([a-z\\d])([A-Z]+)/g, '$1_$2').replace(/([A-Z\\d]+)([A-Z][a-z])/g, '$1_$2').replace(/[-\\s]+/g, '_').toLowerCase();\n      return new this.constructor(s);\n    },\n    unescapeHTML: function () {\n      //from underscore.string\n      return new this.constructor(this.s.replace(/\\&([^;]+);/g, function (entity, entityCode) {\n        var match;\n\n        if (entityCode in escapeChars) {\n          return escapeChars[entityCode];\n        } else if (match = entityCode.match(/^#x([\\da-fA-F]+)$/)) {\n          return String.fromCharCode(parseInt(match[1], 16));\n        } else if (match = entityCode.match(/^#(\\d+)$/)) {\n          return String.fromCharCode(~~match[1]);\n        } else {\n          return entity;\n        }\n      }));\n    },\n    valueOf: function () {\n      return this.s.valueOf();\n    },\n    //#Added a New Function called wrapHTML.\n    wrapHTML: function (tagName, tagAttrs) {\n      var s = this.s,\n          el = tagName == null ? 'span' : tagName,\n          elAttr = '',\n          wrapped = '';\n      if (typeof tagAttrs == 'object') for (var prop in tagAttrs) elAttr += ' ' + prop + '=\"' + new this.constructor(tagAttrs[prop]).escapeHTML() + '\"';\n      s = wrapped.concat('<', el, elAttr, '>', this, '</', el, '>');\n      return new this.constructor(s);\n    }\n  };\n\n  var methodsAdded = [];\n\n  function extendPrototype() {\n    for (var name in __sp) {\n      (function (name) {\n        var func = __sp[name];\n\n        if (!__nsp.hasOwnProperty(name)) {\n          methodsAdded.push(name);\n\n          __nsp[name] = function () {\n            String.prototype.s = this;\n            return func.apply(this, arguments);\n          };\n        }\n      })(name);\n    }\n  }\n\n  function restorePrototype() {\n    for (var i = 0; i < methodsAdded.length; ++i) delete String.prototype[methodsAdded[i]];\n\n    methodsAdded.length = 0;\n  }\n  /*************************************\n  /* Attach Native JavaScript String Properties\n  /*************************************/\n\n\n  var nativeProperties = getNativeStringProperties();\n\n  for (var name in nativeProperties) {\n    (function (name) {\n      var stringProp = __nsp[name];\n\n      if (typeof stringProp == 'function') {\n        //console.log(stringProp)\n        if (!__sp[name]) {\n          if (nativeProperties[name] === 'string') {\n            __sp[name] = function () {\n              //console.log(name)\n              return new this.constructor(stringProp.apply(this, arguments));\n            };\n          } else {\n            __sp[name] = stringProp;\n          }\n        }\n      }\n    })(name);\n  }\n  /*************************************\n  /* Function Aliases\n  /*************************************/\n\n\n  __sp.repeat = __sp.times;\n  __sp.include = __sp.contains;\n  __sp.toInteger = __sp.toInt;\n  __sp.toBool = __sp.toBoolean;\n  __sp.decodeHTMLEntities = __sp.decodeHtmlEntities; //ensure consistent casing scheme of 'HTML'\n  //******************************************************************************\n  // Set the constructor.  Without this, string.js objects are instances of\n  // Object instead of S.\n  //******************************************************************************\n\n  __sp.constructor = S;\n  /*************************************\n  /* Private Functions\n  /*************************************/\n\n  function getNativeStringProperties() {\n    var names = getNativeStringPropertyNames();\n    var retObj = {};\n\n    for (var i = 0; i < names.length; ++i) {\n      var name = names[i];\n      if (name === 'to' || name === 'toEnd') continue; // get rid of the shelljs prototype messup\n\n      var func = __nsp[name];\n\n      try {\n        var type = typeof func.apply('teststring');\n        retObj[name] = type;\n      } catch (e) {}\n    }\n\n    return retObj;\n  }\n\n  function getNativeStringPropertyNames() {\n    var results = [];\n\n    if (Object.getOwnPropertyNames) {\n      results = Object.getOwnPropertyNames(__nsp);\n      results.splice(results.indexOf('valueOf'), 1);\n      results.splice(results.indexOf('toString'), 1);\n      return results;\n    } else {\n      //meant for legacy cruft, this could probably be made more efficient\n      var stringNames = {};\n      var objectNames = [];\n\n      for (var name in String.prototype) stringNames[name] = name;\n\n      for (var name in Object.prototype) delete stringNames[name]; //stringNames['toString'] = 'toString'; //this was deleted with the rest of the object names\n\n\n      for (var name in stringNames) {\n        results.push(name);\n      }\n\n      return results;\n    }\n  }\n\n  function Export(str) {\n    return new S(str);\n  }\n\n  ; //attach exports to StringJSWrapper\n\n  Export.extendPrototype = extendPrototype;\n  Export.restorePrototype = restorePrototype;\n  Export.VERSION = VERSION;\n  Export.TMPL_OPEN = '{{';\n  Export.TMPL_CLOSE = '}}';\n  Export.ENTITIES = ENTITIES;\n  /*************************************\n  /* Exports\n  /*************************************/\n\n  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n    module.exports = Export;\n  } else {\n    if (typeof define === \"function\" && define.amd) {\n      define([], function () {\n        return Export;\n      });\n    } else {\n      window.S = Export;\n    }\n  }\n  /*************************************\n  /* 3rd Party Private Functions\n  /*************************************/\n  //from sugar.js\n\n\n  function multiArgs(args, fn) {\n    var result = [],\n        i;\n\n    for (i = 0; i < args.length; i++) {\n      result.push(args[i]);\n      if (fn) fn.call(args, args[i], i);\n    }\n\n    return result;\n  } //from underscore.string\n\n\n  var escapeChars = {\n    lt: '<',\n    gt: '>',\n    quot: '\"',\n    apos: \"'\",\n    amp: '&'\n  };\n\n  function escapeRegExp(s) {\n    // most part from https://github.com/skulpt/skulpt/blob/ecaf75e69c2e539eff124b2ab45df0b01eaf2295/src/str.js#L242\n    var c;\n    var i;\n    var ret = [];\n    var re = /^[A-Za-z0-9]+$/;\n    s = ensureString(s);\n\n    for (i = 0; i < s.length; ++i) {\n      c = s.charAt(i);\n\n      if (re.test(c)) {\n        ret.push(c);\n      } else {\n        if (c === \"\\\\000\") {\n          ret.push(\"\\\\000\");\n        } else {\n          ret.push(\"\\\\\" + c);\n        }\n      }\n    }\n\n    return ret.join(\"\");\n  }\n\n  function ensureString(string) {\n    return string == null ? '' : '' + string;\n  } //from underscore.string\n\n\n  var reversedEscapeChars = {};\n\n  for (var key in escapeChars) {\n    reversedEscapeChars[escapeChars[key]] = key;\n  }\n\n  ENTITIES = {\n    \"amp\": \"&\",\n    \"gt\": \">\",\n    \"lt\": \"<\",\n    \"quot\": \"\\\"\",\n    \"apos\": \"'\",\n    \"AElig\": 198,\n    \"Aacute\": 193,\n    \"Acirc\": 194,\n    \"Agrave\": 192,\n    \"Aring\": 197,\n    \"Atilde\": 195,\n    \"Auml\": 196,\n    \"Ccedil\": 199,\n    \"ETH\": 208,\n    \"Eacute\": 201,\n    \"Ecirc\": 202,\n    \"Egrave\": 200,\n    \"Euml\": 203,\n    \"Iacute\": 205,\n    \"Icirc\": 206,\n    \"Igrave\": 204,\n    \"Iuml\": 207,\n    \"Ntilde\": 209,\n    \"Oacute\": 211,\n    \"Ocirc\": 212,\n    \"Ograve\": 210,\n    \"Oslash\": 216,\n    \"Otilde\": 213,\n    \"Ouml\": 214,\n    \"THORN\": 222,\n    \"Uacute\": 218,\n    \"Ucirc\": 219,\n    \"Ugrave\": 217,\n    \"Uuml\": 220,\n    \"Yacute\": 221,\n    \"aacute\": 225,\n    \"acirc\": 226,\n    \"aelig\": 230,\n    \"agrave\": 224,\n    \"aring\": 229,\n    \"atilde\": 227,\n    \"auml\": 228,\n    \"ccedil\": 231,\n    \"eacute\": 233,\n    \"ecirc\": 234,\n    \"egrave\": 232,\n    \"eth\": 240,\n    \"euml\": 235,\n    \"iacute\": 237,\n    \"icirc\": 238,\n    \"igrave\": 236,\n    \"iuml\": 239,\n    \"ntilde\": 241,\n    \"oacute\": 243,\n    \"ocirc\": 244,\n    \"ograve\": 242,\n    \"oslash\": 248,\n    \"otilde\": 245,\n    \"ouml\": 246,\n    \"szlig\": 223,\n    \"thorn\": 254,\n    \"uacute\": 250,\n    \"ucirc\": 251,\n    \"ugrave\": 249,\n    \"uuml\": 252,\n    \"yacute\": 253,\n    \"yuml\": 255,\n    \"copy\": 169,\n    \"reg\": 174,\n    \"nbsp\": 160,\n    \"iexcl\": 161,\n    \"cent\": 162,\n    \"pound\": 163,\n    \"curren\": 164,\n    \"yen\": 165,\n    \"brvbar\": 166,\n    \"sect\": 167,\n    \"uml\": 168,\n    \"ordf\": 170,\n    \"laquo\": 171,\n    \"not\": 172,\n    \"shy\": 173,\n    \"macr\": 175,\n    \"deg\": 176,\n    \"plusmn\": 177,\n    \"sup1\": 185,\n    \"sup2\": 178,\n    \"sup3\": 179,\n    \"acute\": 180,\n    \"micro\": 181,\n    \"para\": 182,\n    \"middot\": 183,\n    \"cedil\": 184,\n    \"ordm\": 186,\n    \"raquo\": 187,\n    \"frac14\": 188,\n    \"frac12\": 189,\n    \"frac34\": 190,\n    \"iquest\": 191,\n    \"times\": 215,\n    \"divide\": 247,\n    \"OElig;\": 338,\n    \"oelig;\": 339,\n    \"Scaron;\": 352,\n    \"scaron;\": 353,\n    \"Yuml;\": 376,\n    \"fnof;\": 402,\n    \"circ;\": 710,\n    \"tilde;\": 732,\n    \"Alpha;\": 913,\n    \"Beta;\": 914,\n    \"Gamma;\": 915,\n    \"Delta;\": 916,\n    \"Epsilon;\": 917,\n    \"Zeta;\": 918,\n    \"Eta;\": 919,\n    \"Theta;\": 920,\n    \"Iota;\": 921,\n    \"Kappa;\": 922,\n    \"Lambda;\": 923,\n    \"Mu;\": 924,\n    \"Nu;\": 925,\n    \"Xi;\": 926,\n    \"Omicron;\": 927,\n    \"Pi;\": 928,\n    \"Rho;\": 929,\n    \"Sigma;\": 931,\n    \"Tau;\": 932,\n    \"Upsilon;\": 933,\n    \"Phi;\": 934,\n    \"Chi;\": 935,\n    \"Psi;\": 936,\n    \"Omega;\": 937,\n    \"alpha;\": 945,\n    \"beta;\": 946,\n    \"gamma;\": 947,\n    \"delta;\": 948,\n    \"epsilon;\": 949,\n    \"zeta;\": 950,\n    \"eta;\": 951,\n    \"theta;\": 952,\n    \"iota;\": 953,\n    \"kappa;\": 954,\n    \"lambda;\": 955,\n    \"mu;\": 956,\n    \"nu;\": 957,\n    \"xi;\": 958,\n    \"omicron;\": 959,\n    \"pi;\": 960,\n    \"rho;\": 961,\n    \"sigmaf;\": 962,\n    \"sigma;\": 963,\n    \"tau;\": 964,\n    \"upsilon;\": 965,\n    \"phi;\": 966,\n    \"chi;\": 967,\n    \"psi;\": 968,\n    \"omega;\": 969,\n    \"thetasym;\": 977,\n    \"upsih;\": 978,\n    \"piv;\": 982,\n    \"ensp;\": 8194,\n    \"emsp;\": 8195,\n    \"thinsp;\": 8201,\n    \"zwnj;\": 8204,\n    \"zwj;\": 8205,\n    \"lrm;\": 8206,\n    \"rlm;\": 8207,\n    \"ndash;\": 8211,\n    \"mdash;\": 8212,\n    \"lsquo;\": 8216,\n    \"rsquo;\": 8217,\n    \"sbquo;\": 8218,\n    \"ldquo;\": 8220,\n    \"rdquo;\": 8221,\n    \"bdquo;\": 8222,\n    \"dagger;\": 8224,\n    \"Dagger;\": 8225,\n    \"bull;\": 8226,\n    \"hellip;\": 8230,\n    \"permil;\": 8240,\n    \"prime;\": 8242,\n    \"Prime;\": 8243,\n    \"lsaquo;\": 8249,\n    \"rsaquo;\": 8250,\n    \"oline;\": 8254,\n    \"frasl;\": 8260,\n    \"euro;\": 8364,\n    \"image;\": 8465,\n    \"weierp;\": 8472,\n    \"real;\": 8476,\n    \"trade;\": 8482,\n    \"alefsym;\": 8501,\n    \"larr;\": 8592,\n    \"uarr;\": 8593,\n    \"rarr;\": 8594,\n    \"darr;\": 8595,\n    \"harr;\": 8596,\n    \"crarr;\": 8629,\n    \"lArr;\": 8656,\n    \"uArr;\": 8657,\n    \"rArr;\": 8658,\n    \"dArr;\": 8659,\n    \"hArr;\": 8660,\n    \"forall;\": 8704,\n    \"part;\": 8706,\n    \"exist;\": 8707,\n    \"empty;\": 8709,\n    \"nabla;\": 8711,\n    \"isin;\": 8712,\n    \"notin;\": 8713,\n    \"ni;\": 8715,\n    \"prod;\": 8719,\n    \"sum;\": 8721,\n    \"minus;\": 8722,\n    \"lowast;\": 8727,\n    \"radic;\": 8730,\n    \"prop;\": 8733,\n    \"infin;\": 8734,\n    \"ang;\": 8736,\n    \"and;\": 8743,\n    \"or;\": 8744,\n    \"cap;\": 8745,\n    \"cup;\": 8746,\n    \"int;\": 8747,\n    \"there4;\": 8756,\n    \"sim;\": 8764,\n    \"cong;\": 8773,\n    \"asymp;\": 8776,\n    \"ne;\": 8800,\n    \"equiv;\": 8801,\n    \"le;\": 8804,\n    \"ge;\": 8805,\n    \"sub;\": 8834,\n    \"sup;\": 8835,\n    \"nsub;\": 8836,\n    \"sube;\": 8838,\n    \"supe;\": 8839,\n    \"oplus;\": 8853,\n    \"otimes;\": 8855,\n    \"perp;\": 8869,\n    \"sdot;\": 8901,\n    \"lceil;\": 8968,\n    \"rceil;\": 8969,\n    \"lfloor;\": 8970,\n    \"rfloor;\": 8971,\n    \"lang;\": 9001,\n    \"rang;\": 9002,\n    \"loz;\": 9674,\n    \"spades;\": 9824,\n    \"clubs;\": 9827,\n    \"hearts;\": 9829,\n    \"diams;\": 9830\n  };\n}.call(this);","map":null,"metadata":{},"sourceType":"script"}